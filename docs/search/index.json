[{"content":"一、iptables iptables是运行在用户空间的软件，通过控制内核中的netfilter模块来实现对网络的管理。实际上我们只是通过iptables来对内核中的netfilter的规则进行修改，netfilter才是实际工作的模块。\n通常来说iptables仅用于处理IPv4数据包，对于IPv6需要使用ip6tables命令。\n二、netfilter netfilter是在linux内核中的一个软件框架，用于管理网络数据包。有：网络地址转换、数据包修改、数据包过滤、防火墙等功能。\n我们可以使用用户空间中的iptables、nftables、ebtables和arptables等软件来控制netfilter，进而管理通过本系统的数据包。\n三、基础 iptables根据规则来对数据包进行管理，一条规则包含：动作、源地址、目的地址、协议等信息。\n协议可以查看/etc/protocols/中定义的协议类型，可使用名字(不区分大小写)、对应编号。缺省值为0，代表tcp、udp、icmp而不是定义的所有协议类型。\n1.五链 五链就是指图中的：prerouting、input、forward、postrouting、output五种数据包动作。 例如：\n 到本机某进程的数据包：prerouting、input 进过本机转发的数据包：prerouting、forward、postrouting 本机发出的数据包：output、postrouting  2.四表 iptables把功能相似的规则放在同一张表中，默认为我们创建了四张表：\n filter：过滤数据包。内核模块：iptables_filter nat：网络地址转换。内核模块：iptable_nat mangle：拆解、修改、重新发送数据包。内核模块：iptable_mangle raw：决定数据包是否被状态跟踪机制处理。内核模块：iptable_raw  3.链和表的关系 不同表能作用的链的关系如表：\n   四表/五链 PREROUTING INPUT FORWARD OUTPUT POSTROUTING     filter  √ √ √    nat √ √(centos7)  √ √   mangle √ √ √ √ √   raw √   √     表的优先级关系：raw \u0026gt; mangle \u0026gt; nat \u0026gt; filter，raw的最高。\n四、规则 规则是根据指定的匹配条件来尝试匹配每个流经此处的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理。\n1. 匹配条件 匹配条件分为基本匹配条件与扩展匹配条件：\n 基本匹配条件： 源地址Source IP，目标地址 Destination IP 上述内容都可以作为基本匹配条件。 扩展匹配条件： 除了上述的条件可以用于匹配，还有很多其他的条件可以用于匹配，这些条件泛称为扩展条件，这些扩展条件其实也是netfilter中的一部分，只是以模块的形式存在，如果想要使用这些条件，则需要依赖对应的扩展模块。  下面仅列出常用的简单匹配规则。\n1.1 IP地址匹配 我们可以使用-s和-d指定匹配源IP和目的IP，还可以使用!来表示取反，多个规则时使用,号隔开。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # 单个匹配 iptables -I INPUT -s 1.1.1.2 -j DROP # 多个匹配 iptables -I INPUT -s 1.1.1.3,1.1.1.4 -j DROP # 网段匹配 iptables -I INPUT -s 1.1.1.5/23 -j DROP # 取反匹配 iptables -I INPUT ! -s 1.1.1.6 -j ACCEPT # 源和目的IP匹配 iptables -I INPUT -s 1.1.1.7 -d 1.1.1.8 -j DROP   1.2 协议匹配 我们可以使用-p指定匹配的协议，可使用协议名称(不区分大小写)，或对应编号。支持协议可查看/etc/protocols中的内容，也可以查看相关RFC文档定义的协议和对应编号。\n在指定IP地址匹配的同时可指定具体协议，例如：\n1 2  # 不响应指定源IP的ping数据包 iptables -I INPUT -s 1.1.1.2 -p icmp -j DROP   1.3 接口匹配 我们还可以使用-i和-o参数根据流入和流出的接口来匹配。-i匹配流入的网卡，作用于PREROUTING、INPUT、FORWARD；-o匹配流出的网卡，作用于FORWARD、OUTPUT、POSTROUTING。\n1.4 端口匹配 端口匹配属于扩展匹配条件，需要依赖扩展模块。\n  单端口匹配\n单端口匹配依赖tcp扩展模块，使用-m tcp指定扩展模块，然后使用--dport指定目的端口；--sport指定源端口。以22:55的形式指定端口范围。例如：\n1 2  # 丢弃来自1.1.1.2的tcp协议且目的端口是22的数据包 iptables -I INPUT -s 1.1.1.2 -p tcp -m tcp --dport 22 -j DROP     多端口匹配\n多端口匹配适用于同时指定多个离散的端口，需要依赖multiport扩展模块。例如：\n1  iptables -I INPUT -s 1.1.1.2 -p tcp -m multiport --dports 22,36,80 -j DROP     2. 处理动作 处理动作在iptables中被称为target（这样说并不准确，我们暂且这样称呼），动作也可以分为基本动作和扩展动作。 此处列出一些常用的动作，之后的文章会对它们进行详细的示例与总结：\n  ACCEPT：允许数据包通过。\n  DROP：直接丢弃数据包，不给任何回应信息，这时候客户端会感觉自己的请求泥牛入海了，过了超时时间才会有反应。\n  REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息。\n可附加–reject-with参数，指定拒绝对方时的响应类型，缺省为icmp-port-unreachable。可指定的类型有：icmp-net-unreachable、icmp-host-unreachable、icmp-port-unreachable、icmp-proto-unreachable、icmp-net-prohibited、icmp-host-pro-hibited、icmp-admin-prohibited。\n  SNAT：源地址转换，解决内网用户用同一个公网地址上网的问题。\n  MASQUERADE：是SNAT的一种特殊形式，适用于动态的、临时会变的ip上。\n  DNAT：目标地址转换。\n  REDIRECT：在本机做端口映射。\n  LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。\n  补充一下DROP和REJECT的区别。DROP是直接把匹配到的报文丢弃，REJECT除了把报文丢弃还会给该报文中的源IP发一个ICMP报文说明目的不可达(直接回复不可达, 更强硬)。前者报文发送方只能等超时，而后者发送方因为收到了ICMP不可达所以马上就给出了提示。\n五、命令使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  ~ # iptables -h iptables v1.4.21 Usage: iptables -[ACD] chain rule-specification [options] iptables -I chain [rulenum] rule-specification [options] iptables -R chain rulenum rule-specification [options] iptables -D chain rulenum [options] iptables -[LS] [chain [rulenum]] [options] iptables -[FZ] [chain] [options] iptables -[NX] chain iptables -E old-chain-name new-chain-name iptables -P chain target [options] iptables -h (print this help information) Commands: Either long or short options are allowed. --append -A chain Append to chain --check -C chain Check for the existence of a rule --delete -D chain Delete matching rule from chain --delete -D chain rulenum Delete rule rulenum (1 = first) from chain --insert -I chain [rulenum] Insert in chain as rulenum (default 1=first) --replace -R chain rulenum Replace rule rulenum (1 = first) in chain --list -L [chain [rulenum]] List the rules in a chain or all chains --list-rules -S [chain [rulenum]] Print the rules in a chain or all chains --flush -F [chain] Delete all rules in chain or all chains --zero -Z [chain [rulenum]] Zero counters in chain or all chains --new -N chain Create a new user-defined chain --delete-chain -X [chain] Delete a user-defined chain --policy -P chain target Change policy on chain to target --rename-chain -E old-chain new-chain Change chain name, (moving any references) Options: --ipv4 -4 Nothing (line is ignored by ip6tables-restore) --ipv6 -6 Error (line is ignored by iptables-restore) [!] --protocol -p proto protocol: by number or name, eg. `tcp\u0026#39; [!] --source -s address[/mask][...] source specification [!] --destination -d address[/mask][...] destination specification [!] --in-interface -i input name[+] network interface name ([+] for wildcard) --jump -j target target for rule (may load target extension) --goto -g chain jump to chain with no return --match -m match extended match (may load extension) --numeric -n numeric output of addresses and ports [!] --out-interface -o output name[+] network interface name ([+] for wildcard) --table -t table table to manipulate (default: `filter\u0026#39;) --verbose -v verbose mode --wait -w wait for the xtables lock --line-numbers print line numbers when listing --exact -x expand numbers (display exact values) [!] --fragment -f match second or further fragments only --modprobe=\u0026lt;command\u0026gt; try to insert modules using this command --set-counters PKTS BYTES set the counter during insert/append [!] --version -V print package version.   六、filter表实践 filter是负责数据包过滤的表，是我们最常用的表。\n首先查看filter表中原有的规则：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  ~ # iptables -t filter -nvL --line Chain INPUT (policy ACCEPT 6214 packets, 569K bytes) num pkts bytes target prot opt in out source destination 1 9889 1160K ACCEPT all -- eth0.1 * 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 2 5 320 DROP icmp -- eth0.1 * 0.0.0.0/0 0.0.0.0/0 icmptype 8 3 7007 630K access_ctrl all -- * * 0.0.0.0/0 0.0.0.0/0 4 522 34807 DROP all -- eth0.1 * 0.0.0.0/0 0.0.0.0/0 Chain FORWARD (policy ACCEPT 26932 packets, 6125K bytes) num pkts bytes target prot opt in out source destination Chain OUTPUT (policy ACCEPT 32373 packets, 8525K bytes) num pkts bytes target prot opt in out source destination 1 1354 83951 dns_drop udp -- * * 0.0.0.0/0 0.0.0.0/0 udp dpt:53 state NEW Chain access_ctrl (1 references) num pkts bytes target prot opt in out source destination 1 0 0 ACCEPT icmp -- eth0.1 * 0.0.0.0/0 0.0.0.0/0 2 0 0 ACCEPT tcp -- eth0.1 * 0.0.0.0/0 0.0.0.0/0 tcp dpt:1723 3 0 0 ACCEPT udp -- eth0.1 * 0.0.0.0/0 0.0.0.0/0 udp dpt:1701 4 0 0 ACCEPT 41 -- eth0.1 * 0.0.0.0/0 0.0.0.0/0 Chain dns_drop (1 references) num pkts bytes target prot opt in out source destination   添加不响应测试主机ping的规则：\n1  ~ # iptables -I INPUT -s 192.168.1.141 -p icmp -j DROP   测试：\n删除规则：\n1 2 3 4 5 6 7 8 9  ~ # iptables -L INPUT --line Chain INPUT (policy ACCEPT) num target prot opt source destination 1 DROP icmp -- 192.168.1.141 anywhere 2 ACCEPT all -- anywhere anywhere state RELATED,ESTABLISHED 3 DROP icmp -- anywhere anywhere icmp echo-request 4 access_ctrl all -- anywhere anywhere 5 DROP all -- anywhere anywhere ~ # iptables -D INPUT 1   再次测试：\n","date":"2022-03-16T19:46:25-07:00","permalink":"https://blog.zooter.com.cn/posts/iptables%E7%AE%80%E4%BB%8B/","title":"Iptables简介"},{"content":"一、IPv6动态寻址 IPv6动态寻址有三种方式：无状态地址自动配置(SLAAC)、无状态DHCPv6、有状态DHCPv6。\n其中有无状态是指IP地址能否被统一管理，例如：有状态DHCPv6指IP地址由DHCPv6服务器分配，网络管理员能通过DHCPv6服务对IP地址进行统一管理。\n二、RA/RS消息 RA/RS分别是路由通告消息和路由请求消息的缩写，这两个消息类型是ICMPv6邻居发现协议定义的。\n2.1 RA路由通告消息 RA消息由IPv6路由器向多播地址ff02::1发送，目的是宣布自身存在以及向消息发送接口所连链路有关的IPv6地址信息和配置参数，如：链路的IPv6前缀、前缀长度、默认网关的地址、链路最大传输单元(MTU)。\n通常的IPv6路由器会定时向链路发送路由通告消息，如果收到设备发送的RS消息，也会立即发送RA消息。\n2.1.1 A、O、M标志位 RA消息中可携带三种标志位，向IPv6设备建议如何创建或获取地址。\n  A标志位（地址自动配置标记）\n该标志位出现在RA消息的Option中的Prefix Information里。当该标志位打开(置1)时，表示建议主机采用SLAAC方式来创建地址，采用RA消息中的前缀加上接口ID生成地址。\n  O标志位（其他配置标记）\n该标志位出现在RA消息主体里。当该标志位打开(置1)时，表示建议主机采用SLAAC方式来创建地址，通过DHCPv6服务器获取除地址以外的其他地址信息，如：DNS服务器的IP地址和域名。\n  M标志位（管理地址配置标记）\n该标志位出现在RA消息主体里。当该标志位打开(置1)时，表示建议主机从DHCPv6服务器获取地址及所有其他地址信息，只从RA消息中获取IPv6网关地址。\n   M O A IP地址 其他配置     0 0 0 静态设置 手工配置   0 0 1 前缀由 RA 指定，自动生成 手工配置   0 1 0 静态设置 DHCPv6   0 1 1 前缀由 RA 指定，自动生成 DHCPv6   1 0 0 有状态 DHCPv6 DHCPv6   1 0 1 有状态 DHCPv6 和/或 自动生成 DHCPv6   1 1 0 有状态 DHCPv6 DHCPv6   1 1 1 有状态 DHCPv6 和/或 自动生成 DHCPv6      2.2 RS路由恳求消息 RS消息由IPv6设备向多播地址ff02::2发送，源地址是设备的本地链路地址(LLA)或IPv6未指定地址(::)，目的是向IPv6路由器请求链路地址相关的信息。\n三、无状态地址自动配置(SLAAC) 以下是SLAAC配置地址的流程：\n  客户端接口启动成功后，向ff02::2发送RS消息。\n源地址为客户端的本地链路地址(LLA)，目的地址是代表所有IPv6路由器的多播地址。\n  IPv6路由器接收到RS消息后，立即向ff02::1或客户端LLA发送RA消息。\n因为采用SLAAC自动生成地址，所以RA消息中的A标志位置1，O和M标志位置0。\n源地址为IPv6路由器的本地链路地址，目的地址是客户端的本地链路地址，M标志位为0，O标志位为1（M20-8G和AC5客供软件在设置为SLAAC模式后，RA消息中O标志位都置为1，暂不清楚原因）。\n在选项中可以看到：A标志位为1，表示建议客户端自动生成地址；当前链路的MTU位1500；DNS服务器为fc00::ac6:b3ff:feb9:689d\n  客户端使用RA报文中的前缀和接口ID生成IP地址。\n  四、无状态DHCPv6 无状态DHCPv6的地址配置过程与SLAAC类似，但增加了与DHCP服务器交互的过程。以下是无状态DHCPv6配置地址的流程：\n  客户端接口启动成功后，向ff02::2发送RS消息。\n源地址为客户端的本地链路地址(LLA)，目的地址是代表所有IPv6路由器的多播地址。\n  IPv6路由器接收到RS消息后，立即向ff02::1或客户端LLA发送RA消息。\n因为采用SLAAC自动生成地址，所以RA消息中的A和O标志位置1，M标志位置0。\n源地址为IPv6路由器的本地链路地址，目的地址是代表所有IPv6客户端的多播地址，M标志位为0，O标志位为1。\n在选项中可以看到：A标志位为1，表示建议客户端自动生成地址。\n  客户端使用RA报文中的前缀和接口ID生成IP地址。\n  客户端发送DHCPv6恳求消息寻找DHCPv6服务器。\n源地址为客户端本地链路地址，目的地址为代表所有DHCPv6服务器和中继服务器的多播地址ff02::1:2，目的是定位DHCPv6服务器。\n  DHCPv6服务器回应请求，发送DHCPv6通告消息。\nDHCPv6服务器发送通告消息，源地址是DHCPv6服务器本地链路地址，目的地址是客户端的本地链路地址。\n  客户端发送DHCPv6信息请求消息。\n客户端再发送信息请求消息，请求从DHCPv6服务器获取地址参数（不是地址）。\n  DHCPv6服务器回应请求，发送DHCPv6应答消息。\nDHCPv6服务器发送应答消息，其中包含地址参数，如图：DNS服务器地址。\n  五、有状态DHCPv6 有状态DHCPv6地址分配方式即除了IPv6网关信息外，其他所有地址信息都从DHCPv6服务器获取，以下是有状态DHCPv6配置地址的流程：\n 客户端接口启动成功后，向ff02::2发送RS消息。  源地址是客户端本地链路地址，目的地址是ff02::2所有IPv6路由器。\nIPv6路由器接收到RS消息后，立即向ff02::1或客户端LLA发送RA消息。  由于是有状态DHCPv6，A标志位置0，O和M标志位置1。表示建议客户端从DHCPv6服务器获取地址和地址配置。\n 客户端使用RA报文中的IPv6网关地址。\n客户端从RA报文中只采用IPv6网关地址，其他信息从DHCPv6服务器获取。\n  客户端发送DHCPv6恳求消息寻找DHCPv6服务器。\n  ff02::1:2表示所有DHCPv6服务器和中继服务器。\nDHCPv6服务器回应请求，发送DHCPv6通告消息。  客户端发送DHCPv6信息请求消息。   DHCPv6服务器回应请求，发送DHCPv6应答消息。\n  在回应消息中，DHCPv6服务器提供了IP地址及其他的配置信息，如图：DNS服务器地址\n IPv6动态地址分配机制详解\nDHCPv6基础\n ","date":"2022-03-13T18:44:42-07:00","permalink":"https://blog.zooter.com.cn/posts/ipv6lan%E4%BE%A7%E5%8A%A8%E6%80%81%E5%AF%BB%E5%9D%80/","title":"IPv6LAN侧动态寻址"},{"content":"1. 简介 网络地址转换，可以解决IPv4地址匮乏的问题，同时带有过滤的功能(防火墙)。\nPS：在IPv4时代NAT是非常受欢迎的，但随着IPv6的来临，应尽量避免使用NAT，所需的安全(防火墙)等功能应采取其他措施解决。\n2. 术语 2.1 内部Tuple 指内部主机的私有地址和端口号所构成的二元组，即内部主机所发送报文的源地址、端口所构成的二元组。\n2.2 外部Tuple 指内部Tuple经过NAT的源地址/端口转换之后，所获得的外部地址、端口所构成的二元组，即外部主机收到经NAT转换之后的报文时，它所看到的该报文的源地址（通常是NAT设备的地址）和源端口。\n2.3 目标Tuple 指外部主机的地址、端口所构成的二元组，即内部主机所发送报文的目标地址、端口所构成的二元组。\n2.4 Basic NAT（基本NAT） 只进行IP地址转换。在这种模式下，多台内部主机访问外部网络需要同等数量的公网IP地址，即需要一定数量的NAT地址池。\n2.5 NATP（网络地址-端口转换） NATP是在狭义NAT的基础上增加对端口的转换。这种模式下多台内部主机可经由一个公网IP地址访问外部网络，目前家用宽带主要的NAT模式。\n3. NAT的类型 3.1 Full Cone NAT（锥形NAT） 所有来自同一 个内部Tuple X的请求均被NAT转换至同一个外部Tuple Y，而不管这些请求是不是属于同一个应用或者是多个应用的。除此之外，当X-Y的转换关系建立之后，任意外部主机均可随时将Y中的地址和端口作为目标地址和目标端口，向内部主机发送UDP报文，由于对外部请求的来源无任何限制，因此这种方式虽然足够简单，但却不那么安全。（任意的外部主机/port都能和先前内部节点被映射的外部Tuple进行通信）\n3.2 Restricted Cone NAT（受限的锥形NAT） 它是Full Cone的受限版本：所有来自同一个内部Tuple X的请求均被NAT转换至同一个外部Tuple Y，这与Full Cone相同，但不同的是，只有当内部主机曾经发送过报文给外部主机（假设其IP地址为Z）后，外部主机才能以Y中的信息作为目标地址和目标端口，向内部主机发送UDP请求报文，这意味着，NAT设备只向内转发（目标地址/端口转换）那些来自于当前已知的外部主机的UDP报文，从而保障了外部请求来源的安全性。（IP相同，port随便，就能和先前内部节点被映射的外部Tuple进行通信）\n3.3 Port Restricted Cone NAT（严格限制的锥形NAT） 它是Restricted Cone NAT的进一步受限版。只有当内部主机曾经发送过报文给外部主机（假设其IP地址为Z且端口为P）之后，外部主机才能以Y中的信息作为目标地址和目标端 口，向内部主机发送UDP报文，同时，其请求报文的源端口必须为P，这一要求进一步强化了对外部报文请求来源的限制，从而较Restrictd Cone更具安全性 （ip,port都得一样；只能用先前内部节点被映射的外部Tuple与内部节点进行通信））\n3.4 Symmetric NAT（对称NAT） 在Cone NAT中，NAT转换映射关系仅与内部Tuple和外部Tuple相关，与目标Tuple无关。而在Symmetric NAT中，即使内部Tuple和外部Tuple相同，但目标Tuple不同，在此情况下将建立两条转换映射关系。此外，NAT的过滤方式与Port Restricted Cone相同。\n NAT的四种类型及类型检测 - bw_0927 - 博客园\n","date":"2022-03-11T00:03:02-08:00","permalink":"https://blog.zooter.com.cn/posts/nat%E7%AE%80%E4%BB%8B/","title":"NAT简介"},{"content":"802.11k 802.11k协议的功能是Radio Resource Measurment，简单说就是提供找到最好的AP的信息。\n在WLAN中，终端设备总是倾向于连接信号最好的那个AP，而在实际应用中，这种逻辑可能会造成某个AP被过度使用，而信号稍弱的AP则没有怎么用到，从而导致网络的整体利用效率下降。实现802.11k协议的无线网络中，如果信号最好的AP已经满载，则终端设备会连接到信号稍弱的那个AP。\n协议步骤：\n AP决定要踢掉某个终端设备 通知终端设备变换到另一个AP 终端设备请求周围AP的列表 AP给出site report 终端设备根据site report连到某个AP  802.11v 802.11v是802.11协议族的WNM（Wireless Network Management）标准，802.11v协议允许终端设备交换网络拓扑的信息，包括射频环境。\n802.11v描述了WNM的增强，包括：\n Network assisted Power Savings：网络辅助节能，帮助终端设备睡眠更长时间，比如，手机等设备通过每隔一段时间跟AP通讯一次来确保跟AP没有断开 Network assisted Roaming：网络辅助漫游，允许WLAN发送信息给终端，来确保终端能连接更好的AP。  这可以带来两点好处：\n 负载均衡 让信号不好的终端设备更换AP  802.11r 802.11r的功能是快速BSS切换（FT，Fast Basic Service Set Transition），也称为快速漫游（fast roaming），是802.11协议的补充。\n在802.11协议中，AP的切换是由设备控制的（其逻辑是：在能连接到的信号中，挑选信号最好的那个连接，连接一直持续到信号低于一个阈值（通常非常弱）才会断开，然后继续反复）。\n在802.11的初期，切换（handoff）这个操作是非常简单的，一共只有4个握手信息需要传递，但是随着发展，802.11i，802.11X，802.11e等协议的加入，握手的信息越来越多，导致切换AP的时间越来越长。\n802.11r通过重新简化（越来越复杂的）安全握手协议，来实现FT。\n","date":"2022-03-11T10:37:45+08:00","permalink":"https://blog.zooter.com.cn/posts/802.11-kvr/","title":"802.11 kvr协议简述"}]